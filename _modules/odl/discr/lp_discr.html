

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>odl.discr.lp_discr &mdash; odl 0.6.1.dev0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="odl 0.6.1.dev0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                0.6.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.discr.lp_discr</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.discr.lp_discr</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2017 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;:math:`L^p` type discretizations of function spaces.&quot;&quot;&quot;</span>

<span class="c1"># Imports for common Python 2/3 codebase</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">str</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>

<span class="kn">from</span> <span class="nn">odl.discr.discretization</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">DiscretizedSpace</span><span class="p">,</span> <span class="n">DiscretizedSpaceElement</span><span class="p">,</span> <span class="n">dspace_type</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.discr.discr_mappings</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">PointCollocation</span><span class="p">,</span> <span class="n">NearestInterpolation</span><span class="p">,</span> <span class="n">LinearInterpolation</span><span class="p">,</span>
    <span class="n">PerAxisInterpolation</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.discr.partition</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">RectPartition</span><span class="p">,</span> <span class="n">uniform_partition_fromintv</span><span class="p">,</span> <span class="n">uniform_partition</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.set</span> <span class="k">import</span> <span class="n">RealNumbers</span><span class="p">,</span> <span class="n">ComplexNumbers</span><span class="p">,</span> <span class="n">IntervalProd</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="k">import</span> <span class="n">FunctionSpace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">,</span> <span class="n">fn_impl</span>
<span class="kn">from</span> <span class="nn">odl.space.weighting</span> <span class="k">import</span> <span class="n">Weighting</span><span class="p">,</span> <span class="n">NoWeighting</span><span class="p">,</span> <span class="n">ConstWeighting</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">apply_on_boundary</span><span class="p">,</span> <span class="n">is_real_dtype</span><span class="p">,</span> <span class="n">is_complex_floating_dtype</span><span class="p">,</span>
    <span class="n">dtype_str</span><span class="p">,</span> <span class="n">signature_string</span><span class="p">,</span> <span class="n">indent_rows</span><span class="p">,</span> <span class="n">is_string</span><span class="p">,</span>
    <span class="n">normalized_scalar_param_list</span><span class="p">,</span> <span class="n">safe_int_conv</span><span class="p">,</span> <span class="n">normalized_nodes_on_bdry</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util.ufuncs</span> <span class="k">import</span> <span class="n">DiscreteLpUfuncs</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;DiscreteLp&#39;</span><span class="p">,</span> <span class="s1">&#39;DiscreteLpElement&#39;</span><span class="p">,</span>
           <span class="s1">&#39;uniform_discr_frompartition&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform_discr_fromspace&#39;</span><span class="p">,</span>
           <span class="s1">&#39;uniform_discr_fromintv&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform_discr&#39;</span><span class="p">,</span>
           <span class="s1">&#39;uniform_discr_fromdiscr&#39;</span><span class="p">,</span> <span class="s1">&#39;discr_sequence_space&#39;</span><span class="p">)</span>

<span class="n">_SUPPORTED_INTERP</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="DiscreteLp"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp.html#odl.discr.lp_discr.DiscreteLp">[docs]</a><span class="k">class</span> <span class="nc">DiscreteLp</span><span class="p">(</span><span class="n">DiscretizedSpace</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Discretization of a Lebesgue :math:`L^p` space.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fspace</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fspace : `FunctionSpace`</span>
<span class="sd">            The continuous space to be discretized</span>
<span class="sd">        partition : `RectPartition`</span>
<span class="sd">            Partition of (a subset of) ``fspace.domain`` based on a</span>
<span class="sd">            `RectGrid`.</span>
<span class="sd">        dspace : `FnBase`</span>
<span class="sd">            Space of elements used for data storage. It must have the</span>
<span class="sd">            same `FnBase.field` as ``fspace``</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            The parameter :math:`p` in :math:`L^p`. If the exponent is</span>
<span class="sd">            not equal to the default 2.0, the space has no inner</span>
<span class="sd">            product.</span>
<span class="sd">        interp : string or sequence of strings, optional</span>
<span class="sd">            The interpolation type to be used for discretization.</span>
<span class="sd">            A sequence is interpreted as interpolation scheme per</span>
<span class="sd">            axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation (default)</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">            Ordering of the axes in the data storage. &#39;C&#39; means the</span>
<span class="sd">            first axis varies slowest, the last axis fastest;</span>
<span class="sd">            vice versa for &#39;F&#39;.</span>
<span class="sd">            Default: &#39;C&#39;</span>
<span class="sd">        axis_labels : sequence of str, optional</span>
<span class="sd">            Names of the axes to use for plotting etc. Default:</span>

<span class="sd">                1D: ``[&#39;$x$&#39;]``</span>

<span class="sd">                2D: ``[&#39;$x$&#39;, &#39;$y$&#39;]``</span>

<span class="sd">                3D: ``[&#39;$x$&#39;, &#39;$y$&#39;, &#39;$z$&#39;]``</span>

<span class="sd">                nD: ``[&#39;$x_1$&#39;, &#39;$x_2$&#39;, ..., &#39;$x_n$&#39;]``</span>

<span class="sd">            Note: The ``$`` signs ensure rendering as LaTeX.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a FunctionSpace instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">IntervalProd</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;function space domain </span><span class="si">{!r}</span><span class="s1"> is not an &#39;</span>
                            <span class="s1">&#39;IntervalProd instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">RectPartition</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`partition` </span><span class="si">{!r}</span><span class="s1"> is not a RectPartition &#39;</span>
                            <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">contains_set</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`partition` </span><span class="si">{}</span><span class="s1"> is not a subset of the function &#39;</span>
                             <span class="s1">&#39;domain </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fspace</span><span class="o">.</span><span class="n">out_dtype</span> <span class="o">!=</span> <span class="n">dspace</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`out_dtype` of Function Space </span><span class="si">{}</span><span class="s1"> does not match &#39;</span>
                             <span class="s1">&#39;dspace dtype </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">dspace</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">interp</span><span class="p">):</span>
            <span class="n">interp</span><span class="p">,</span> <span class="n">interp_in</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">interp</span>
            <span class="k">if</span> <span class="n">interp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SUPPORTED_INTERP</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`interp=</span><span class="si">{!r}</span><span class="s1">` not understood&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interp_in</span><span class="p">))</span>
            <span class="c1"># Ensure that there is 1 entry for ndim == 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__interp_byaxis</span> <span class="o">=</span> <span class="p">(</span><span class="n">interp</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Got sequence of strings</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">partition</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected </span><span class="si">{}</span><span class="s1"> (ndim) entries in `interp`, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interp</span><span class="p">)))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__interp_byaxis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">interp</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SUPPORTED_INTERP</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`interp` sequence </span><span class="si">{}</span><span class="s1"> contains illegal &#39;</span>
                                 <span class="s1">&#39;values&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interp</span><span class="p">))</span>

        <span class="n">order</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`order` </span><span class="si">{!r}</span><span class="s1"> not recognized&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__order</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__partition</span> <span class="o">=</span> <span class="n">partition</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="n">PointCollocation</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span>
                                    <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">):</span>
            <span class="n">interpol</span> <span class="o">=</span> <span class="n">NearestInterpolation</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span>
                                            <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">):</span>
            <span class="n">interpol</span> <span class="o">=</span> <span class="n">LinearInterpolation</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span>
                                           <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interpol</span> <span class="o">=</span> <span class="n">PerAxisInterpolation</span><span class="p">(</span>
                <span class="n">fspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">interpol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="p">,</span> <span class="s1">&#39;exponent&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="n">dspace</span><span class="o">.</span><span class="n">exponent</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`exponent` </span><span class="si">{}</span><span class="s1"> not equal to data space exponent &#39;</span>
                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">dspace</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axis_labels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="s1">&#39;$z$&#39;</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s1">&#39;$x_</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">axis_labels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown arguments </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolation type of this discretization.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">interp</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
               <span class="k">for</span> <span class="n">interp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_byaxis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interp_byaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolation by axis type of this discretization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interp_byaxis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axis_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Labels for axes when displaying space elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_pt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector of minimal coordinates of the function domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">min_pt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_pt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector of maximal coordinates of the function domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">max_pt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Axis ordering for array flattening.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`RectPartition` of the domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__partition</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniform_byaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean tuple showing uniformity of ``self.partition`` per axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">is_uniform_byaxis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if `partition` is uniform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">is_uniform</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sampling grid of the discretization mappings.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape of the underlying partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of underlying partition cells.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Side lengths of a cell in an underlying *uniform* partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_sides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cell volume of an underlying regular partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_volume</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All sampling points in the partition as a sparse meshgrid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">meshgrid</span>

<div class="viewcode-block" id="DiscreteLp.points"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp.points.html#odl.discr.lp_discr.DiscreteLp.points">[docs]</a>    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All sampling points in the partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">points</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent ``p`` in ``L^p``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exponent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tangent_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The tangent bundle associated with `domain` using `partition`.</span>

<span class="sd">        The tangent bundle of a space ``X`` of functions ``R^d --&gt; F`` can be</span>
<span class="sd">        interpreted as the space of vector-valued functions ``R^d --&gt; F^d``.</span>
<span class="sd">        This space can be identified with the power space ``X^d`` as used</span>
<span class="sd">        in this implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniformly_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the weighting of the space is the same for all points.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_uniformly_weighted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_uniformly_weighted</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">is_uniformly_weighted</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="p">,</span> <span class="s1">&#39;is_weighted&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__is_uniformly_weighted</span> <span class="o">=</span> <span class="n">is_uniformly_weighted</span>

        <span class="k">return</span> <span class="n">is_uniformly_weighted</span>

<div class="viewcode-block" id="DiscreteLp.element"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp.element.html#odl.discr.lp_discr.DiscreteLp.element">[docs]</a>    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an element from ``inp`` or from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : optional</span>
<span class="sd">            Input data to create an element from.</span>

<span class="sd">            If ``inp`` is callable, it needs to be understood by the</span>
<span class="sd">            ``uspace.element`` method.</span>

<span class="sd">            Otherwise, it has to be understood by the ``dspace.element``</span>
<span class="sd">            method.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Additional arguments passed on to `sampling` when called</span>
<span class="sd">            on ``inp``, in the form ``sampling(inp, **kwargs)``.</span>
<span class="sd">            This can be used e.g. for functions with parameters.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        vectorized : bool</span>
<span class="sd">            Can only be used if ``inp`` is callable, in which case it</span>
<span class="sd">            indicates if ``inp`` is vectorized. If not, it will be wrapped</span>
<span class="sd">            with a vectorizer.</span>
<span class="sd">            Default: True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element : `DiscreteLpElement`</span>
<span class="sd">            The discretized element, calculated as ``sampling(inp)`` or</span>
<span class="sd">            ``dspace.element(inp)``, tried in this order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Elements can be created from array-like objects that represent</span>
<span class="sd">        an already discretized function:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(-1, 1, 4)</span>
<span class="sd">        &gt;&gt;&gt; space.element([1, 2, 3, 4])</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([1.0, 2.0, 3.0, 4.0])</span>
<span class="sd">        &gt;&gt;&gt; vector = odl.rn(4).element([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; space.element(vector)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([0.0, 1.0, 2.0, 3.0])</span>

<span class="sd">        On the other hand, non-discretized objects like Python functions</span>
<span class="sd">        can be discretized &quot;on the fly&quot;:</span>

<span class="sd">        &gt;&gt;&gt; space.element(lambda x: x * 2)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([-1.5, -0.5, 0.5, 1.5])</span>

<span class="sd">        This works also with parameterized functions, however only</span>
<span class="sd">        through keyword arguments (not positional arguments with</span>
<span class="sd">        defaults):</span>

<span class="sd">        &gt;&gt;&gt; def f(x, **kwargs):</span>
<span class="sd">        ...     c = kwargs.pop(&#39;c&#39;, 0.0)</span>
<span class="sd">        ...     return np.maximum(x, c)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(-1, 1, 4)</span>
<span class="sd">        &gt;&gt;&gt; space.element(f, c=0.5)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([0.5, 0.5, 0.5, 0.75])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sampling : create a discrete element from an undiscretized one</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="o">.</span><span class="n">element</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inp</span>
        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="n">vectorized</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vectorized&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="c1"># uspace element -&gt; discretize</span>
            <span class="n">inp_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="n">vectorized</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">(</span><span class="n">inp_elem</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sequence-type input</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Attempt to handle some cases with exact match</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>  <span class="c1"># Squeeze could solve the problem</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;input shape </span><span class="si">{}</span><span class="s1"> does not match grid shape </span><span class="si">{}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># Try to broadcast the array if possible</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c1"># The above requires numpy 1.10, fallback impl else</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
                             <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal helper for ``astype``.&quot;&quot;&quot;</span>
        <span class="n">fspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uspace</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">dspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">fspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span>
                          <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
                          <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">)</span>

    <span class="c1"># Overrides for space functions depending on partition</span>
    <span class="c1">#</span>
    <span class="c1"># The inherited methods by default use a weighting by a constant</span>
    <span class="c1"># (the grid cell size). In dimensions where the partitioned set contains</span>
    <span class="c1"># only a fraction of the outermost cells (e.g. if the outermost grid</span>
    <span class="c1"># points lie at the boundary), the corresponding contribuitons to</span>
    <span class="c1"># discretized integrals need to be scaled by that fraction.</span>
<div class="viewcode-block" id="DiscreteLp._inner"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp._inner.html#odl.discr.lp_discr.DiscreteLp._inner">[docs]</a>    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.inner(x, y)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="c1"># TODO: implement without copying x</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">)</span>

            <span class="n">x_arr</span> <span class="o">=</span> <span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x_arr</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscreteLp._norm"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp._norm.html#odl.discr.lp_discr.DiscreteLp._norm">[docs]</a>    <span class="k">def</span> <span class="nf">_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.norm(x)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="c1"># TODO: implement without copying x</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>

            <span class="n">x_arr</span> <span class="o">=</span> <span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x_arr</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscreteLp._dist"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLp._dist.html#odl.discr.lp_discr.DiscreteLp._dist">[docs]</a>    <span class="k">def</span> <span class="nf">_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.dist(x, y)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="c1"># TODO: implement without copying x</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>

            <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>

            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_dist</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="c1"># Clunky check if the factory repr can be used</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uniform_partition_fromintv</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uspace</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">):</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">uniform_partition_fromintv</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uspace</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">):</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">default_ax_lbl</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="s1">&#39;$z$&#39;</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">default_ax_lbl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s1">&#39;$x_</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">use_uniform</span><span class="p">:</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="s1">&#39;uniform_discr&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_pt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pt</span><span class="p">]]</span>
                <span class="n">posargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">default_dtype_s</span> <span class="o">=</span> <span class="n">dtype_str</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">(</span><span class="n">RealNumbers</span><span class="p">()))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">NoWeighting</span><span class="p">):</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_volume</span><span class="p">))):</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                  <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))):</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="s1">&#39;const&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span>

            <span class="n">dtype_s</span> <span class="o">=</span> <span class="n">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;impl&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">dtype_s</span><span class="p">,</span> <span class="n">default_dtype_s</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;axis_labels&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">,</span> <span class="n">default_ax_lbl</span><span class="p">)]</span>

            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span>
                                         <span class="n">mod</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;!r&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">posargs</span><span class="p">),</span>
                                              <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">optargs</span><span class="p">)])</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">uspace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dspace</span><span class="p">]</span>

            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;axis_labels&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">,</span> <span class="n">default_ax_lbl</span><span class="p">),</span>
                       <span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)]</span>

            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span>
                                         <span class="n">sep</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">],</span>
                                         <span class="n">mod</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;!r&#39;</span><span class="p">,</span> <span class="s1">&#39;!s&#39;</span><span class="p">])</span>

            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">indent_rows</span><span class="p">(</span><span class="n">inner_str</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`DiscreteLpElement`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DiscreteLpElement</span></div>


<div class="viewcode-block" id="DiscreteLpElement"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLpElement.html#odl.discr.lp_discr.DiscreteLpElement">[docs]</a><span class="k">class</span> <span class="nc">DiscreteLpElement</span><span class="p">(</span><span class="n">DiscretizedSpaceElement</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Representation of a `DiscreteLp` element.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiscreteLpElement.asarray"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLpElement.asarray.html#odl.discr.lp_discr.DiscreteLpElement.asarray">[docs]</a>    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the data of this array as a numpy array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            Array in which the result should be written in-place.</span>
<span class="sd">            Has to be contiguous and of the correct dtype and</span>
<span class="sd">            shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">DiscretizedSpaceElement</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">DiscretizedSpaceElement</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">size</span><span class="p">,)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;output array has shape </span><span class="si">{}</span><span class="s1">, expected &#39;</span>
                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> or (</span><span class="si">{}</span><span class="s1">,)&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="n">out_r</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out_r</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
                <span class="n">out_order</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
            <span class="k">elif</span> <span class="n">out_r</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                <span class="n">out_order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;output array not contiguous&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">out_order</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;output array has ordering </span><span class="si">{!r}</span><span class="s1">, &#39;</span>
                                 <span class="s1">&#39;expected </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">out_order</span><span class="p">))</span>

            <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLpElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">out</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multi-dimensional shape of this discrete function.&quot;&quot;&quot;</span>
        <span class="c1"># override shape</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Side lengths of a cell in an underlying *uniform* partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">cell_sides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cell volume of an underlying regular grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">cell_volume</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Axis ordering for array flattening.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Real part of this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the real part of this element to ``newreal``.&quot;&quot;&quot;</span>
        <span class="n">newreal_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">newreal</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">newreal_flat</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Imaginary part of this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the imaginary part of this element to ``newimag``.&quot;&quot;&quot;</span>
        <span class="n">newimag_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">newimag</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">newimag_flat</span>

<div class="viewcode-block" id="DiscreteLpElement.conj"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLpElement.conj.html#odl.discr.lp_discr.DiscreteLpElement.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Complex conjugate of this element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `DiscreteLpElement`, optional</span>
<span class="sd">            Element to which the complex conjugate is written.</span>
<span class="sd">            Must be an element of this element&#39;s space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `DiscreteLpElement`</span>
<span class="sd">            The complex conjugate element. If ``out`` is provided,</span>
<span class="sd">            the returned object is a reference to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; discr = uniform_discr(0, 1, 4, dtype=&#39;complex&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = discr.element([5+1j, 3, 2-2j, 1j])</span>
<span class="sd">        &gt;&gt;&gt; y = x.conj(); print(y)</span>
<span class="sd">        [(5-1j), (3-0j), (2+2j), -1j]</span>

<span class="sd">        The out parameter allows you to avoid a copy:</span>

<span class="sd">        &gt;&gt;&gt; z = discr.element()</span>
<span class="sd">        &gt;&gt;&gt; z_out = x.conj(out=z); print(z)</span>
<span class="sd">        [(5-1j), (3-0j), (2+2j), -1j]</span>
<span class="sd">        &gt;&gt;&gt; z_out is z</span>
<span class="sd">        True</span>

<span class="sd">        It can also be used for in-place conjugation:</span>

<span class="sd">        &gt;&gt;&gt; x_out = x.conj(out=x); print(x)</span>
<span class="sd">        [(5-1j), (3-0j), (2+2j), -1j]</span>
<span class="sd">        &gt;&gt;&gt; x_out is x</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">ntuple</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="DiscreteLpElement.__setitem__"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLpElement.__setitem__.html#odl.discr.lp_discr.DiscreteLpElement.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set values of this element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : int or `slice`</span>
<span class="sd">            The position(s) that should be set</span>
<span class="sd">        values : scalar or `array-like`</span>
<span class="sd">            Value(s) to be assigned.</span>
<span class="sd">            If ``indices`` is an integer, ``values`` must be a scalar</span>
<span class="sd">            value.</span>
<span class="sd">            If ``indices`` is a slice, ``values`` must be</span>
<span class="sd">            broadcastable to the size of the slice (same size,</span>
<span class="sd">            shape ``(1,)`` or scalar).</span>
<span class="sd">            For ``indices == slice(None)``, i.e. in the call</span>
<span class="sd">            ``vec[:] = values``, a multi-dimensional array of correct</span>
<span class="sd">            shape is allowed as ``values``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="c1"># For DiscretizedSetElement of the same type, use ntuple directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ntuple</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ntuple</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Other sequence types are piped through a Numpy array. Equivalent</span>
            <span class="c1"># views are optimized for in Numpy.</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape </span><span class="si">{}</span><span class="s1"> of value array </span><span class="si">{}</span><span class="s1"> not equal &#39;</span>
                                     <span class="s1">&#39;to sampling grid shape </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

            <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteLpElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ufuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`DiscreteLpUfuncs`, access to numpy style ufuncs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; X = uniform_discr(0, 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; x = X.element([1, -2])</span>
<span class="sd">        &gt;&gt;&gt; x.ufuncs.absolute()</span>
<span class="sd">        uniform_discr(0.0, 1.0, 2).element([1.0, 2.0])</span>

<span class="sd">        These functions can also be used with broadcasting</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.add(3)</span>
<span class="sd">        uniform_discr(0.0, 1.0, 2).element([4.0, 1.0])</span>

<span class="sd">        and non-space elements</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.subtract([3, 3])</span>
<span class="sd">        uniform_discr(0.0, 1.0, 2).element([-2.0, -5.0])</span>

<span class="sd">        There is also support for various reductions (sum, prod, min, max)</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.sum()</span>
<span class="sd">        -1.0</span>

<span class="sd">        Also supports out parameter</span>

<span class="sd">        &gt;&gt;&gt; y = X.element([3, 4])</span>
<span class="sd">        &gt;&gt;&gt; out = X.element()</span>
<span class="sd">        &gt;&gt;&gt; result = x.ufuncs.add(y, out=out)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        uniform_discr(0.0, 1.0, 2).element([4.0, 2.0])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        These are optimized to use the underlying ntuple space and incur no</span>
<span class="sd">        overhead unless these do.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DiscreteLpUfuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="DiscreteLpElement.show"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.DiscreteLpElement.show.html#odl.discr.lp_discr.DiscreteLpElement.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">force_show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the function graphically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Set the title of the figure</span>

<span class="sd">        method : string, optional</span>
<span class="sd">            1d methods:</span>

<span class="sd">            - ``&#39;plot&#39;`` : graph plot (default for 1d data)</span>
<span class="sd">            - ``&#39;scatter&#39;`` : scattered 2d points (2nd axis &lt;-&gt; value)</span>

<span class="sd">            2d methods:</span>

<span class="sd">            - ``&#39;imshow&#39;`` : image plot with coloring according to value,</span>
<span class="sd">              including a colorbar (default for 2d data).</span>
<span class="sd">            - ``&#39;scatter&#39;`` : cloud of scattered 3d points</span>
<span class="sd">              (3rd axis &lt;-&gt; value)</span>

<span class="sd">        coords : `array-like`, optional</span>
<span class="sd">            Display a slice of the array instead of the full array.</span>
<span class="sd">            The values are shown accordinging to the given values,</span>
<span class="sd">            where ``None`` means all values along that dimension. For</span>
<span class="sd">            example, ``[None, None, 0.5]`` shows all values in the first</span>
<span class="sd">            two dimensions, with the third coordinate equal to 0.5.</span>
<span class="sd">            If a sequence is provided, it specifies the minimum and maximum</span>
<span class="sd">            point to be shown, i.e. ``[None, [0, 1]]`` shows all of the</span>
<span class="sd">            first axis and values between 0 and 1 in the second.</span>
<span class="sd">            This option is mutually exclusive with ``indices``.</span>

<span class="sd">        indices : int, slice, Ellipsis or sequence, optional</span>
<span class="sd">            Display a slice of the array instead of the full array.</span>
<span class="sd">            If a sequence is given, the i-th entry indexes the i-th axis,</span>
<span class="sd">            with the following behavior for the different types of entries:</span>

<span class="sd">                - ``int``: take entries with this index along axis ``i``,</span>
<span class="sd">                  removing this axis from the result</span>
<span class="sd">                - ``slice``: take a subset along axis ``i``, keeping it</span>
<span class="sd">                  intact</span>
<span class="sd">                - ``None``: equivalent to ``slice(None)``</span>
<span class="sd">                - ``Ellipsis`` (``...``): equivalent to the number of</span>
<span class="sd">                  ``None`` entries required to fill up the sequence to</span>
<span class="sd">                  correct length.</span>

<span class="sd">            The typical use case is to show a slice for a fixed index in</span>
<span class="sd">            a specific axis, which can be done most easily by setting, e.g.,</span>
<span class="sd">            ``indices=[None, 50, None]`` to take the 2d slice parallel to</span>
<span class="sd">            the x-z coordinate plane at index ``y = 50``.</span>

<span class="sd">            A single ``int`` or ``slice`` object indexes the first</span>
<span class="sd">            axis, i.e., is treated as ``(int_or_slice, Ellipsis)``.</span>
<span class="sd">            For the default ``None``, the array is kepty as-is for data</span>
<span class="sd">            that has at most 2 dimensions. For higher-dimensional</span>
<span class="sd">            data, the 2d slice in the first two axes at the middle</span>
<span class="sd">            position along the remaining axes is shown</span>
<span class="sd">            (semantically ``[:, :, shape[2:] // 2]``).</span>
<span class="sd">            This option is mutually exclusive with ``coords``.</span>

<span class="sd">        force_show : bool, optional</span>
<span class="sd">            Whether the plot should be forced to be shown now or deferred until</span>
<span class="sd">            later. Note that some backends always displays the plot, regardless</span>
<span class="sd">            of this value.</span>

<span class="sd">        fig : `matplotlib.figure.Figure`, optional</span>
<span class="sd">            The figure to show in. Expected to be of same &quot;style&quot;, as</span>
<span class="sd">            the figure given by this function. The most common use case</span>
<span class="sd">            is that ``fig`` is the return value of an earlier call to</span>
<span class="sd">            this function.</span>

<span class="sd">        kwargs : {&#39;figsize&#39;, &#39;saveto&#39;, &#39;clim&#39;, ...}, optional</span>
<span class="sd">            Extra keyword arguments passed on to the display method.</span>
<span class="sd">            See the Matplotlib functions for documentation of extra</span>
<span class="sd">            options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : `matplotlib.figure.Figure`</span>
<span class="sd">            The resulting figure. It is also shown to the user.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.util.graphics.show_discrete_data : Underlying implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">odl.util.graphics</span> <span class="k">import</span> <span class="n">show_discrete_data</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nothing to show for 0-dimensional vector&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot provide both coords and indices&#39;</span><span class="p">)</span>

            <span class="n">partition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">coords</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">coord_minp</span><span class="p">,</span> <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">coord</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">coord_minp</span> <span class="o">=</span> <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">coord</span>

                <span class="n">subpart</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

                <span class="c1"># Validate input</span>
                <span class="k">if</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_minp</span> <span class="o">=</span> <span class="n">subpart</span><span class="o">.</span><span class="n">set</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coord_maxp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">subpart</span><span class="o">.</span><span class="n">set</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">coord_maxp</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpart</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># trivial cases</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord_minp</span> <span class="o">==</span> <span class="n">coord_maxp</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">min_ind</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">min_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">,</span>
                                                         <span class="n">floating</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">coord_maxp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">max_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpart</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">max_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_maxp</span><span class="p">,</span>
                                                        <span class="n">floating</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">min_ind</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_ind</span><span class="p">)))</span>

        <span class="c1"># Default to showing x-y slice &quot;in the middle&quot;</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">((</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>

        <span class="c1"># Normalize indices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">(</span><span class="n">Integral</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">indices</span> <span class="o">==</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Single index or slice indexes the first axis, rest untouched</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span>

        <span class="c1"># Convert `Ellipsis` objects</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot use more than 1 `Ellipsis` (`...`)&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="c1"># Replace Ellipsis with the correct number of `slice(None)`</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span> <span class="o">+</span>
                       <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># Now indices should be exactly of length `ndim`</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too few axes (</span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too many axes (</span><span class="si">{}</span><span class="s1"> &gt; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="c1"># Map `None` to `slice(None)` in indices for syntax like `coords`</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">idx</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

        <span class="n">squeezed_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                         <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)]</span>
        <span class="n">axis_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">squeezed_axes</span><span class="p">]</span>

        <span class="c1"># Squeeze grid and values according to the index expression</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asarray</span><span class="p">()[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">show_discrete_data</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                  <span class="n">force_show</span><span class="o">=</span><span class="n">force_show</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                  <span class="n">axis_labels</span><span class="o">=</span><span class="n">axis_labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="uniform_discr_frompartition"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.uniform_discr_frompartition.html#odl.discr.lp_discr.uniform_discr_frompartition">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_frompartition</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Discretize an Lp function space given a uniform partition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partition : `RectPartition`</span>
<span class="sd">        Regular (uniform) partition to be used for discretization</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter ``p`` in ``L^p``. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    interp : string or sequence of strings, optional</span>
<span class="sd">        Interpolation type to be used for discretization.</span>
<span class="sd">        A sequence is interpreted as interpolation scheme per axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Axis ordering in the data storage. Default: &#39;C&#39;</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Data type for the discretized space</span>

<span class="sd">            Default for &#39;numpy&#39;: &#39;float64&#39; / &#39;complex128&#39;</span>

<span class="sd">            Default for &#39;cuda&#39;: &#39;float32&#39;</span>

<span class="sd">    weighting : {&#39;const&#39;, &#39;none&#39;}, optional</span>
<span class="sd">        Weighting of the discretized space functions.</span>

<span class="sd">            &#39;const&#39; : weight is a constant, the cell volume (default)</span>

<span class="sd">            &#39;none&#39; : no weighting</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscreteLp`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; part = odl.uniform_partition(0, 1, 10)</span>
<span class="sd">    &gt;&gt;&gt; uniform_discr_frompartition(part)</span>
<span class="sd">    uniform_discr(0.0, 1.0, 10)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    uniform_discr_fromspace : uniform Lp discretization from an existing</span>
<span class="sd">        function space</span>
<span class="sd">    odl.discr.partition.uniform_partition :</span>
<span class="sd">        partition of the function domain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">RectPartition</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`partition` </span><span class="si">{!r}</span><span class="s1"> is not a `RectPartition` instance&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">partition</span><span class="o">.</span><span class="n">is_uniform</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`partition` is not uniform&#39;</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">fspace</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">set</span><span class="p">,</span> <span class="n">out_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ds_type</span> <span class="o">=</span> <span class="n">dspace_type</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">ds_type</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">()</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="n">weighting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">Weighting</span><span class="p">):</span>
        <span class="n">weighting</span><span class="p">,</span> <span class="n">weighting_in</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">weighting</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="n">weighting</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span>
            <span class="n">weighting</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">partition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">partition</span><span class="o">.</span><span class="n">cell_volume</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`weighting` &#39;</span><span class="si">{}</span><span class="s2">&#39; not understood&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting_in</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dspace</span> <span class="o">=</span> <span class="n">ds_type</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">,</span>
                         <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dspace</span> <span class="o">=</span> <span class="n">ds_type</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">,</span>
                         <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">DiscreteLp</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">dspace</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr_fromspace"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.uniform_discr_fromspace.html#odl.discr.lp_discr.uniform_discr_fromspace">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_fromspace</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                            <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Discretize an Lp function space by uniform partition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fspace : `FunctionSpace`</span>
<span class="sd">        Continuous function space. Its domain must be an</span>
<span class="sd">        `IntervalProd` instance.</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter ``p`` in ``L^p``. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    interp : string or sequence of strings, optional</span>
<span class="sd">        Interpolation type to be used for discretization.</span>
<span class="sd">        A sequence is interpreted as interpolation scheme per axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single bool or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``len(shape)``.</span>

<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Axis ordering in the data storage. Default: &#39;C&#39;</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type for the discretized space. If not specified, the</span>
<span class="sd">        `FunctionSpace.out_dtype` of ``fspace`` is used.</span>
<span class="sd">    weighting : {&#39;const&#39;, &#39;none&#39;}, optional</span>
<span class="sd">        Weighting of the discretized space functions.</span>

<span class="sd">            &#39;const&#39; : Weight is a constant, the cell volume (default).</span>

<span class="sd">            &#39;none&#39; : No weighting.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscreteLp`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; intv = odl.IntervalProd(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; space = odl.FunctionSpace(intv)</span>
<span class="sd">    &gt;&gt;&gt; uniform_discr_fromspace(space, 10)</span>
<span class="sd">    uniform_discr(0.0, 1.0, 10)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    uniform_discr_frompartition : uniform Lp discretization using a given</span>
<span class="sd">        uniform partition of a function domain</span>
<span class="sd">    uniform_discr_fromintv : uniform discretization from an existing</span>
<span class="sd">        interval product</span>
<span class="sd">    odl.discr.partition.uniform_partition :</span>
<span class="sd">        partition of the function domain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`fspace` </span><span class="si">{!r}</span><span class="s1"> is not a `FunctionSpace` instance&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">IntervalProd</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;domain </span><span class="si">{!r}</span><span class="s1"> of the function space is not an &#39;</span>
                        <span class="s1">&#39;`IntervalProd` instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Set data type. If given check consistency with fspace&#39;s field and</span>
    <span class="c1"># out_dtype. If not given, take the latter.</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">fspace</span><span class="o">.</span><span class="n">out_dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">dtype_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot safely cast from output data </span><span class="si">{}</span><span class="s1"> type of &#39;</span>
                             <span class="s1">&#39;the function space to given data type </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype_in</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">fspace</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot discretize real space </span><span class="si">{}</span><span class="s1"> with &#39;</span>
                         <span class="s1">&#39;non-real data type </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">()</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="n">is_complex_floating_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot discretize complex space </span><span class="si">{}</span><span class="s1"> with &#39;</span>
                         <span class="s1">&#39;non-complex-floating data type </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>

    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">partition</span> <span class="o">=</span> <span class="n">uniform_partition_fromintv</span><span class="p">(</span><span class="n">fspace</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                           <span class="n">nodes_on_bdry</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uniform_discr_frompartition</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr_fromintv"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.uniform_discr_fromintv.html#odl.discr.lp_discr.uniform_discr_fromintv">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_fromintv</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                           <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Discretize an Lp function space by uniform sampling.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : `IntervalProd`</span>
<span class="sd">        The domain of the uniformly discretized space.</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter :math:`p` in :math:`L^p`. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    interp : string or sequence of strings, optional</span>
<span class="sd">        Interpolation type to be used for discretization.</span>
<span class="sd">        A sequence is interpreted as interpolation scheme per axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">    impl : str, optional</span>
<span class="sd">        Implementation of the data storage arrays.</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single bool or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``array.ndim``.</span>

<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>
<span class="sd">        Default: ``False``</span>

<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type for the discretized space</span>

<span class="sd">            Default for &#39;numpy&#39;: &#39;float64&#39; / &#39;complex128&#39;</span>

<span class="sd">            Default for &#39;cuda&#39;: &#39;float32&#39;</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Ordering of the axes in the data storage. &#39;C&#39; means the</span>
<span class="sd">        first axis varies slowest, the last axis fastest;</span>
<span class="sd">        vice versa for &#39;F&#39;.</span>
<span class="sd">        Default: &#39;C&#39;</span>
<span class="sd">    weighting : {&#39;const&#39;, &#39;none&#39;}, optional</span>
<span class="sd">        Weighting of the discretized space functions.</span>

<span class="sd">            &#39;const&#39; : weight is a constant, the cell volume (default)</span>

<span class="sd">            &#39;none&#39; : no weighting</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscreteLp`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; intv = IntervalProd(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; uniform_discr_fromintv(intv, 10)</span>
<span class="sd">    uniform_discr(0.0, 1.0, 10)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    uniform_discr_frompartition : uniform Lp discretization using a given</span>
<span class="sd">        uniform partition of a function domain</span>
<span class="sd">    uniform_discr_fromspace : uniform discretization from an existing</span>
<span class="sd">        function space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">fn_impl</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">()</span>

    <span class="n">fspace</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">out_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniform_discr_fromspace</span><span class="p">(</span><span class="n">fspace</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.uniform_discr.html#odl.discr.lp_discr.uniform_discr">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                  <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Discretize an Lp function space by uniform sampling.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min_pt : float or sequence of floats</span>
<span class="sd">        Maximum corners of the desired function domain.</span>
<span class="sd">    max_pt : float or sequence of floats</span>
<span class="sd">        Minimum corners of the desired function domain.</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter :math:`p` in :math:`L^p`. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    interp : string or sequence of strings, optional</span>
<span class="sd">        Interpolation type to be used for discretization.</span>
<span class="sd">        A sequence is interpreted as interpolation scheme per axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays.</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single bool or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``len(shape)``.</span>

<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type for the discretized space</span>

<span class="sd">            Default for &#39;numpy&#39;: &#39;float64&#39; / &#39;complex128&#39;</span>

<span class="sd">            Default for &#39;cuda&#39;: &#39;float32&#39;</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Ordering of the axes in the data storage. &#39;C&#39; means the</span>
<span class="sd">        first axis varies slowest, the last axis fastest;</span>
<span class="sd">        vice versa for &#39;F&#39;.</span>
<span class="sd">        Default: &#39;C&#39;</span>
<span class="sd">    weighting : {&#39;const&#39;, &#39;none&#39;}, optional</span>
<span class="sd">        Weighting of the discretized space functions.</span>

<span class="sd">            &#39;const&#39; : weight is a constant, the cell volume (default)</span>

<span class="sd">            &#39;none&#39; : no weighting</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscreteLp`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create real space:</span>

<span class="sd">    &gt;&gt;&gt; uniform_discr([0, 0], [1, 1], [10, 10])</span>
<span class="sd">    uniform_discr([0.0, 0.0], [1.0, 1.0], (10, 10))</span>

<span class="sd">    Can create complex space by giving a dtype</span>

<span class="sd">    &gt;&gt;&gt; uniform_discr([0, 0], [1, 1], [10, 10], dtype=&#39;complex&#39;)</span>
<span class="sd">    uniform_discr([0.0, 0.0], [1.0, 1.0], (10, 10), dtype=&#39;complex&#39;)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr_frompartition : uniform Lp discretization using a given</span>
<span class="sd">        uniform partition of a function domain</span>
<span class="sd">    uniform_discr_fromspace : uniform discretization from an existing</span>
<span class="sd">        function space</span>
<span class="sd">    uniform_discr_fromintv : uniform discretization from an existing</span>
<span class="sd">        interval product</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniform_discr_fromintv</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="discr_sequence_space"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.discr_sequence_space.html#odl.discr.lp_discr.discr_sequence_space">[docs]</a><span class="k">def</span> <span class="nf">discr_sequence_space</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an object mimicing the sequence space ``l^p(R^d)``.</span>

<span class="sd">    The returned object is a `DiscreteLp` without sampling and</span>
<span class="sd">    interpolation operators. It uses a grid with stride 1 and no</span>
<span class="sd">    weighting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of element entries per axis.</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter ``p`` in ```L^p``. If the exponent is</span>
<span class="sd">        not equal to the default 2.0, the space has no inner</span>
<span class="sd">        product.</span>
<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type for the discretized space</span>

<span class="sd">            Default for &#39;numpy&#39;: &#39;float64&#39;</span>

<span class="sd">            Default for &#39;cuda&#39;: &#39;float32&#39;</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Ordering of the axes in the data storage. &#39;C&#39; means the</span>
<span class="sd">        first axis varies slowest, the last axis fastest;</span>
<span class="sd">        vice versa for &#39;F&#39;.</span>
<span class="sd">        Default: &#39;C&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seqspc : `DiscreteLp`</span>
<span class="sd">        Sequence-space-like discrete Lp.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seq_spc = discr_sequence_space((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; seq_spc.one().norm() == 3.0</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; seq_spc = discr_sequence_space((3, 3), exponent=1)</span>
<span class="sd">    &gt;&gt;&gt; seq_spc.one().norm() == 9.0</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniform_discr</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">,</span>
                         <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">weighting</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr_fromdiscr"><a class="viewcode-back" href="../../../generated/odl.discr.lp_discr.uniform_discr_fromdiscr.html#odl.discr.lp_discr.uniform_discr_fromdiscr">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_fromdiscr</span><span class="p">(</span><span class="n">discr</span><span class="p">,</span> <span class="n">min_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                            <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a discretization based on an existing one.</span>

<span class="sd">    The parameters that are explicitly given are used to create the</span>
<span class="sd">    new discretization, and the missing information is taken from</span>
<span class="sd">    the template space. See Notes for the exact functionality.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    discr : `DiscreteLp`</span>
<span class="sd">        Uniformly discretized space used as a template.</span>
<span class="sd">    min_pt : float or sequence of floats, optional</span>
<span class="sd">        Minimum corners of the desired function domain.</span>
<span class="sd">    max_pt : float or sequence of floats, optional</span>
<span class="sd">        Maximum corners of the desired function domain.</span>
<span class="sd">    shape : int or sequence of ints, optional</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    cell_sides : array-like, optional</span>
<span class="sd">        Side length of each cell.</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter :math:`p` in :math:`L^p`. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    interp : string or sequence of strings, optional</span>
<span class="sd">        Interpolation type to be used for discretization.</span>
<span class="sd">        A sequence is interpreted as interpolation scheme per axis.</span>

<span class="sd">            &#39;nearest&#39; : use nearest-neighbor interpolation</span>

<span class="sd">            &#39;linear&#39; : use linear interpolation</span>

<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays. See</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        Specifies whether to put the outmost grid nodes on the</span>
<span class="sd">        boundary of the domain.</span>

<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single boolean or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``discr.ndim``.</span>

<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    dtype : optional</span>
<span class="sd">        Data type for the discretized space.</span>

<span class="sd">            Default for &#39;numpy&#39;: &#39;float64&#39; / &#39;complex128&#39;</span>

<span class="sd">            Default for &#39;cuda&#39;: &#39;float32&#39;</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Ordering of the axes in the data storage. &#39;C&#39; means the</span>
<span class="sd">        first axis varies slowest, the last axis fastest;</span>
<span class="sd">        vice versa for &#39;F&#39;.</span>
<span class="sd">        Default: &#39;C&#39;</span>
<span class="sd">    weighting : {&#39;const&#39;, &#39;none&#39;}, optional</span>
<span class="sd">        Weighting of the discretized space functions.</span>

<span class="sd">            &#39;const&#39; : weight is a constant, the cell volume (default)</span>

<span class="sd">            &#39;none&#39; : no weighting</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters ``min_pt``, ``max_pt``, ``shape`` and</span>
<span class="sd">    ``cell_sides`` can be combined in the following ways (applies in</span>
<span class="sd">    each axis individually):</span>

<span class="sd">    **0 arguments:**</span>
<span class="sd">        Return a copy of ``discr``</span>

<span class="sd">    **1 argument:**</span>
<span class="sd">        [min,max]_pt -&gt; keep sampling but translate domain so it</span>
<span class="sd">        starts/ends at ``[min,max]_pt``</span>

<span class="sd">        shape/cell_sides -&gt; keep domain but change sampling.</span>
<span class="sd">        See `uniform_partition` for restrictions.</span>

<span class="sd">    **2 arguments:**</span>
<span class="sd">        min_pt + max_pt -&gt; translate and resample with the same</span>
<span class="sd">        number of samples</span>

<span class="sd">        [min,max]_pt + shape/cell_sides -&gt; translate and resample</span>

<span class="sd">        shape + cell_sides -&gt; error due to ambiguity (keep</span>
<span class="sd">        ``min_pt`` or ``max_pt``?)</span>

<span class="sd">    **3+ arguments:**</span>
<span class="sd">        The underlying partition is uniquely determined by the new</span>
<span class="sd">        parameters. See `uniform_partition`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    odl.discr.partition.uniform_partition :</span>
<span class="sd">        underlying domain partitioning scheme</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; discr = odl.uniform_discr([0, 0], [1, 2], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; discr.cell_sides</span>
<span class="sd">    array([ 0.1,  0.4])</span>

<span class="sd">    If no additional argument is given, a copy of ``discr`` is</span>
<span class="sd">    returned:</span>

<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr) == discr</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr) is discr</span>
<span class="sd">    False</span>

<span class="sd">    Giving ``min_pt`` or ``max_pt`` results in a</span>
<span class="sd">    translation, while for the other two options, the domain</span>
<span class="sd">    is kept but re-partitioned:</span>

<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, min_pt=[1, 1])</span>
<span class="sd">    uniform_discr([1.0, 1.0], [2.0, 3.0], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, max_pt=[0, 0])</span>
<span class="sd">    uniform_discr([-1.0, -2.0], [0.0, 0.0], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, cell_sides=[1, 1])</span>
<span class="sd">    uniform_discr([0.0, 0.0], [1.0, 2.0], (1, 2))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, shape=[5, 5])</span>
<span class="sd">    uniform_discr([0.0, 0.0], [1.0, 2.0], (5, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, shape=[5, 5]).cell_sides</span>
<span class="sd">    array([ 0.2,  0.4])</span>

<span class="sd">    The cases with 2 or more additional arguments and the syntax</span>
<span class="sd">    for specifying quantities per axis is illustrated in the following:</span>

<span class="sd">    # axis 0: translate to match max_pt = 3</span>
<span class="sd">    # axis 1: recompute max_pt using the original shape with the</span>
<span class="sd">    # new min_pt and cell_sides</span>
<span class="sd">    &gt;&gt;&gt; new_discr = odl.uniform_discr_fromdiscr(discr, min_pt=[None, 1],</span>
<span class="sd">    ...                                         max_pt=[3, None],</span>
<span class="sd">    ...                                         cell_sides=[None, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; new_discr</span>
<span class="sd">    uniform_discr([2.0, 1.0], [3.0, 2.25], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; new_discr.cell_sides</span>
<span class="sd">    array([ 0.1 ,  0.25])</span>

<span class="sd">    # axis 0: recompute min_pt from old cell_sides and new</span>
<span class="sd">    # max_pt and shape</span>
<span class="sd">    # axis 1: use new min_pt, shape and cell_sides only</span>
<span class="sd">    &gt;&gt;&gt; new_discr = odl.uniform_discr_fromdiscr(discr, min_pt=[None, 1],</span>
<span class="sd">    ...                                         max_pt=[3, None],</span>
<span class="sd">    ...                                         shape=[5, 5],</span>
<span class="sd">    ...                                         cell_sides=[None, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; new_discr</span>
<span class="sd">    uniform_discr([2.5, 1.0], [3.0, 2.25], (5, 5))</span>
<span class="sd">    &gt;&gt;&gt; new_discr.cell_sides</span>
<span class="sd">    array([ 0.1 ,  0.25])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">discr</span><span class="p">,</span> <span class="n">DiscreteLp</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`discr` </span><span class="si">{!r}</span><span class="s1"> is not a DiscreteLp instance&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">discr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discr</span><span class="o">.</span><span class="n">is_uniform</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`discr` </span><span class="si">{}</span><span class="s1"> is not uniformly discretized&#39;</span>
                         <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">discr</span><span class="p">))</span>

    <span class="c1"># Normalize partition parameters</span>
    <span class="n">min_pt</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                          <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_pt</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">max_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                          <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                         <span class="n">param_conv</span><span class="o">=</span><span class="n">safe_int_conv</span><span class="p">,</span>
                                         <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cell_sides</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">cell_sides</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                              <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">normalized_nodes_on_bdry</span><span class="p">(</span><span class="n">nodes_on_bdry</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">new_min_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_max_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_csides</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">cell_sides</span><span class="p">,</span>
                <span class="n">discr</span><span class="o">.</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">max_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">discr</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">)):</span>
        <span class="n">num_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">old_xmax</span> <span class="o">+</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">old_xmin</span><span class="p">),</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span> <span class="o">+</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">old_xmax</span><span class="p">),</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;in axis </span><span class="si">{}</span><span class="s1">: cannot use `shape` and &#39;</span>
                                 <span class="s1">&#39;`cell_size` only due to ambiguous values &#39;</span>
                                 <span class="s1">&#39;for `min_pt` and `max_pt`.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="n">new_min_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_max_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">new_csides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">new_part</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="n">min_pt</span><span class="o">=</span><span class="n">new_min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">=</span><span class="n">new_max_pt</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                 <span class="n">cell_sides</span><span class="o">=</span><span class="n">new_csides</span><span class="p">,</span>
                                 <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="n">nodes_on_bdry</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uniform_discr_frompartition</span><span class="p">(</span><span class="n">new_part</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">discr</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                                       <span class="n">interp</span><span class="o">=</span><span class="n">discr</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">discr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of lists of scaling functions for the boundary.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">scaling</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">scaling_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">scaling_func</span>

    <span class="n">func_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">frac_l</span><span class="p">,</span> <span class="n">frac_r</span> <span class="ow">in</span> <span class="n">bdry_fracs</span><span class="p">:</span>
        <span class="n">func_list_entry</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">frac_l</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaling</span><span class="p">(</span><span class="n">frac_l</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">exponent</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">frac_r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaling</span><span class="p">(</span><span class="n">frac_r</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">exponent</span><span class="p">)))</span>

        <span class="n">func_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func_list_entry</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func_list</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># pylint: disable=wrong-import-position</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="k">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, ODL development group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.6.1.dev0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>