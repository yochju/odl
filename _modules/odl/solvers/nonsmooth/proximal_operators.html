

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>odl.solvers.nonsmooth.proximal_operators &mdash; odl 0.6.1.dev0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="odl 0.6.1.dev0 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                0.6.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">odl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.solvers.nonsmooth.proximal_operators</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.solvers.nonsmooth.proximal_operators</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2017 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Factory functions for creating proximal operators.</span>

<span class="sd">Functions with ``convex_conj`` mean the proximal of the convex conjugate and</span>
<span class="sd">are provided for convenience.</span>

<span class="sd">For more details see :ref:`proximal_operators` and references therein. For</span>
<span class="sd">more details on proximal operators including how to evaluate the proximal</span>
<span class="sd">operator of a variety of functions see [PB2014].</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">[PB2014] Parikh, N, and Boyd, S. *Proximal Algorithms*.</span>
<span class="sd">Foundations and Trends in Optimization, 1 (2014), pp 127-239.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Imports for common Python 2/3 codebase</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.operator</span> <span class="k">import</span> <span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">IdentityOperator</span><span class="p">,</span> <span class="n">ScalingOperator</span><span class="p">,</span>
                          <span class="n">ConstantOperator</span><span class="p">,</span> <span class="n">DiagonalOperator</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="k">import</span> <span class="n">ProductSpace</span>
<span class="kn">from</span> <span class="nn">odl.set</span> <span class="k">import</span> <span class="n">LinearSpaceElement</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="k">import</span> <span class="n">cache_arguments</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;combine_proximals&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_convex_conj&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_translation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_arg_scaling&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_quadratic_perturbation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_composition&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_const_func&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_box_constraint&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_nonnegativity&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_l1&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_convex_conj_l1&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_l2&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_convex_conj_l2&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_l2_squared&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_convex_conj_l2_squared&#39;</span><span class="p">,</span>
           <span class="s1">&#39;proximal_convex_conj_kl&#39;</span><span class="p">,</span> <span class="s1">&#39;proximal_convex_conj_kl_cross_entropy&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="combine_proximals"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.combine_proximals.html#odl.solvers.nonsmooth.proximal_operators.combine_proximals">[docs]</a><span class="k">def</span> <span class="nf">combine_proximals</span><span class="p">(</span><span class="o">*</span><span class="n">factory_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine proximal operators into a diagonal product space operator.</span>

<span class="sd">    This assumes the functional to be separable across variables in order to</span>
<span class="sd">    make use of the separable sum property of proximal operators.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    factory_list : sequence of callables</span>
<span class="sd">        Proximal operator factories to be combined.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diag_op : function</span>
<span class="sd">        Returns a diagonal product space operator factory to be initialized</span>
<span class="sd">        with the same step size parameter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    That two functionals :math:`F` and :math:`G` are separable across variables</span>
<span class="sd">    means that :math:`F((x, y)) = F(x)` and :math:`G((x, y)) = G(y)`, and in</span>
<span class="sd">    this case the proximal operator of the sum is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma (F(x) + G(y))}(x, y) =</span>
<span class="sd">        (\mathrm{prox}_{\\sigma F}(x), \mathrm{prox}_{\\sigma G}(y)).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">diag_op_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Diagonal matrix of operators.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diag_op : `DiagonalOperator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factory_list</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">diag_op_factory</span></div>


<div class="viewcode-block" id="proximal_convex_conj"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the proximal of the dual using Moreau decomposition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prox_factory : callable</span>
<span class="sd">        A factory function that, when called with a step size, returns the</span>
<span class="sd">        proximal operator of ``F``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Moreau identity states that for any convex function :math:`F` with</span>
<span class="sd">    convex conjugate :math:`F^*`, the proximals satisfy</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(x) +\\sigma \,</span>
<span class="sd">        \mathrm{prox}_{F / \\sigma}(x / \\sigma) = x</span>

<span class="sd">    where :math:`\\sigma` is a scalar step size. Using this, the proximal of</span>
<span class="sd">    the convex conjugate is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(x) =</span>
<span class="sd">        x - \\sigma \, \mathrm{prox}_{F / \\sigma}(x / \\sigma)</span>

<span class="sd">    Note that since :math:`(F^*)^* = F`, this can be used to get the proximal</span>
<span class="sd">    of the original function from the proximal of the convex conjugate.</span>

<span class="sd">    For reference on the Moreau identity, see [CP2011c].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [CP2011c] Combettes, P L, and Pesquet, J-C. *Proximal splitting</span>
<span class="sd">    methods in signal processing.* In:  Bauschke, H H, Burachik, R S,</span>
<span class="sd">    Combettes, P L, Elser, V, Luke, D R, and Wolkowicz, H. Fixed-point</span>
<span class="sd">    algorithms for inverse problems in science and engineering, Springer,</span>
<span class="sd">    2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">convex_conj_prox_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create proximal for the dual with a given sigma.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : `Operator`</span>
<span class="sd">            The proximal operator of ``s * F^*`` where ``s`` is the step size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">prox_other</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">prox_factory</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">prox_other</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">-</span> <span class="n">prox_other</span>

    <span class="k">return</span> <span class="n">convex_conj_prox_factory</span></div>


<div class="viewcode-block" id="proximal_translation"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_translation.html#odl.solvers.nonsmooth.proximal_operators.proximal_translation">[docs]</a><span class="k">def</span> <span class="nf">proximal_translation</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the proximal of the translated function F(x - y).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prox_factory : callable</span>
<span class="sd">        A factory function that, when called with a step size, returns the</span>
<span class="sd">        proximal operator of ``F``.</span>
<span class="sd">    y : Element in domain of ``F``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a functional :math:`F`, this is calculated according to the rule</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F( \cdot - y)}(x) =</span>
<span class="sd">        y + \mathrm{prox}_{\\sigma F}(x - y)</span>

<span class="sd">    where :math:`y` is the translation, and :math:`\\sigma` is the step size.</span>

<span class="sd">    For reference on the identity used, see [CP2011c].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [CP2011c] Combettes, P L, and Pesquet, J-C. *Proximal splitting</span>
<span class="sd">    methods in signal processing.* In:  Bauschke, H H, Burachik, R S,</span>
<span class="sd">    Combettes, P L, Elser, V, Luke, D R, and Wolkowicz, H. Fixed-point</span>
<span class="sd">    algorithms for inverse problems in science and engineering, Springer,</span>
<span class="sd">    2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">translation_prox_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create proximal for the translation with a given sigma.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : `Operator`</span>
<span class="sd">            The proximal operator of ``s * F( . - y)`` where ``s`` is the</span>
<span class="sd">            step size</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">ConstantOperator</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">prox_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">*</span>
                <span class="p">(</span><span class="n">IdentityOperator</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">space</span><span class="p">)</span> <span class="o">-</span> <span class="n">ConstantOperator</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">translation_prox_factory</span></div>


<div class="viewcode-block" id="proximal_arg_scaling"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_arg_scaling.html#odl.solvers.nonsmooth.proximal_operators.proximal_arg_scaling">[docs]</a><span class="k">def</span> <span class="nf">proximal_arg_scaling</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">,</span> <span class="n">scaling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the proximal of function F(x * scaling).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prox_factory : callable</span>
<span class="sd">        A factory function that, when called with a step size, returns the</span>
<span class="sd">        proximal operator of ``F``</span>
<span class="sd">    scaling : float</span>
<span class="sd">        Scaling parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a functional :math:`F`, and scaling factor :math:`\\alpha` this is</span>
<span class="sd">    calculated according to the rule</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F(\\alpha \, \cdot)}(x) =</span>
<span class="sd">        \\frac{1}{\\alpha}</span>
<span class="sd">        \mathrm{prox}_{\\sigma \\alpha^2 F(\cdot) }(\\alpha x)</span>

<span class="sd">    where :math:`scal` is the scaling parameter, and :math:`\\sigma` is the</span>
<span class="sd">    step size.</span>

<span class="sd">    For reference on the identity used, see [CP2011c].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [CP2011c] Combettes, P L, and Pesquet, J-C. *Proximal splitting</span>
<span class="sd">    methods in signal processing.* In:  Bauschke, H H, Burachik, R S,</span>
<span class="sd">    Combettes, P L, Elser, V, Luke, D R, and Wolkowicz, H. Fixed-point</span>
<span class="sd">    algorithms for inverse problems in science and engineering, Springer,</span>
<span class="sd">    2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">scaling</span><span class="o">.</span><span class="n">imag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;complex scaling not supported.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scaling</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">proximal_const_func</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@cache_arguments</span>
    <span class="k">def</span> <span class="nf">arg_scaling_prox_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create proximal for the translation with a given sigma.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : `Operator`</span>
<span class="sd">            The proximal operator of ``sigma * F( . * a)`` where ``sigma`` is</span>
<span class="sd">            the step size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prox</span> <span class="o">=</span> <span class="n">prox_factory</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">scaling</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">)</span> <span class="o">*</span> <span class="n">prox</span> <span class="o">*</span> <span class="n">scaling</span>

    <span class="k">return</span> <span class="n">arg_scaling_prox_factory</span></div>


<div class="viewcode-block" id="proximal_quadratic_perturbation"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_quadratic_perturbation.html#odl.solvers.nonsmooth.proximal_operators.proximal_quadratic_perturbation">[docs]</a><span class="k">def</span> <span class="nf">proximal_quadratic_perturbation</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the proximal of function F(x) + a * \|x\|^2 + &lt;u,x&gt;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prox_factory : callable</span>
<span class="sd">        A factory function that, when called with a step size, returns the</span>
<span class="sd">        proximal operator of ``F``</span>
<span class="sd">    a : non-negative float</span>
<span class="sd">        Scaling of the quadratic term</span>
<span class="sd">    u : Element in domain of F, optional</span>
<span class="sd">        Defines the linear functional. For ``None``, the zero element</span>
<span class="sd">        is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a functional :math:`F`, this is calculated according to the rule</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma \left(F( \cdot ) + a \| \cdot \|^2 +</span>
<span class="sd">        &lt;u, \cdot &gt;\\right)}(x) =</span>
<span class="sd">        c \; \mathrm{prox}_{\\sigma F( \cdot \, c)}((x - \\sigma u) c)</span>

<span class="sd">    where :math:`c` is the constant</span>

<span class="sd">    .. math::</span>
<span class="sd">        c = \\frac{1}{\\sqrt{2 \\sigma a + 1}},</span>

<span class="sd">    :math:`a` is the scaling parameter belonging to the quadratic term,</span>
<span class="sd">    :math:`u` is the space element defining the linear functional, and</span>
<span class="sd">    :math:`\\sigma` is the step size.</span>

<span class="sd">    For reference on the identity used, see [CP2011c]. Note that this identity</span>
<span class="sd">    is not the exact one given in the reference, but was recalculated for</span>
<span class="sd">    arbitrary step lengths.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [CP2011c] Combettes, P L, and Pesquet, J-C. *Proximal splitting</span>
<span class="sd">    methods in signal processing.* In:  Bauschke, H H, Burachik, R S,</span>
<span class="sd">    Combettes, P L, Elser, V, Luke, D R, and Wolkowicz, H. Fixed-point</span>
<span class="sd">    algorithms for inverse problems in science and engineering, Springer,</span>
<span class="sd">    2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;scaling parameter muts be non-negative, got </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`u` must be `None` or a `LinearSpaceElement` &#39;</span>
                        <span class="s1">&#39;instance, got </span><span class="si">{!r}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="nd">@cache_arguments</span>
    <span class="k">def</span> <span class="nf">quadratic_perturbation_prox_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create proximal for the quadratic perturbation with a given sigma.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : `Operator`</span>
<span class="sd">            The proximal operator of ``sigma * (F(x) + a * \|x\|^2 + &lt;u,x&gt;)``,</span>
<span class="sd">            where ``sigma`` is the step size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">prox</span> <span class="o">=</span> <span class="n">proximal_arg_scaling</span><span class="p">(</span><span class="n">prox_factory</span><span class="p">,</span> <span class="n">const</span><span class="p">)(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">const</span> <span class="o">*</span> <span class="n">prox</span> <span class="o">*</span>
                    <span class="p">(</span><span class="n">ScalingOperator</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">const</span> <span class="o">*</span> <span class="n">u</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">const</span> <span class="o">*</span> <span class="n">prox</span> <span class="o">*</span> <span class="n">const</span>

    <span class="k">return</span> <span class="n">quadratic_perturbation_prox_factory</span></div>


<div class="viewcode-block" id="proximal_composition"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_composition.html#odl.solvers.nonsmooth.proximal_operators.proximal_composition">[docs]</a><span class="k">def</span> <span class="nf">proximal_composition</span><span class="p">(</span><span class="n">proximal</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of functional composed with unitary operator.</span>

<span class="sd">    For a functional ``F`` and a linear unitary `Operator` ``L`` this is the</span>
<span class="sd">    factory for the proximal operator of ``F * L``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    proximal : callable</span>
<span class="sd">        A factory function that, when called with a step size returns the</span>
<span class="sd">        proximal operator of ``F``</span>
<span class="sd">    operator : `Operator`</span>
<span class="sd">        The operator to compose the functional with</span>
<span class="sd">    mu : ``operator.field`` element</span>
<span class="sd">        Scalar such that ``(operator.adjoint * operator)(x) = mu * x``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a linear operator :math:`L` with the property that for a scalar</span>
<span class="sd">    :math:`\\mu`</span>

<span class="sd">    .. math::</span>
<span class="sd">        L^*(L(x)) = \\mu * x</span>

<span class="sd">    and a convex function :math:`F`, the following identity holds</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F \circ L}(x) = x + \\frac{1}{\\mu}</span>
<span class="sd">        L^* \left( \mathrm{prox}_{\\mu \\sigma F}(Lx) - Lx \\right)</span>

<span class="sd">    This factory function implements this functionality.</span>

<span class="sd">    There is no simple formula for more general operators.</span>

<span class="sd">    The function cannot verify that the operator is unitary, the user needs</span>
<span class="sd">    to verify this.</span>

<span class="sd">    For reference on the identity used, see [CP2011c].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [CP2011c] Combettes, P L, and Pesquet, J-C. *Proximal splitting</span>
<span class="sd">    methods in signal processing.* In:  Bauschke, H H, Burachik, R S,</span>
<span class="sd">    Combettes, P L, Elser, V, Luke, D R, and Wolkowicz, H. Fixed-point</span>
<span class="sd">    algorithms for inverse problems in science and engineering, Springer,</span>
<span class="sd">    2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">proximal_composition_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create proximal for the dual with a given sigma</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Step size parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : `Operator`</span>
<span class="sd">            The proximal operator of ``prox[sigma * F * L](x)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="n">Ir</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">)</span>
        <span class="n">prox_muf</span> <span class="o">=</span> <span class="n">proximal</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Id</span> <span class="o">+</span>
                <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span> <span class="o">*</span> <span class="p">((</span><span class="n">prox_muf</span> <span class="o">-</span> <span class="n">Ir</span><span class="p">)</span> <span class="o">*</span> <span class="n">operator</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">proximal_composition_factory</span></div>


<div class="viewcode-block" id="proximal_const_func"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_const_func.html#odl.solvers.nonsmooth.proximal_operators.proximal_const_func">[docs]</a><span class="k">def</span> <span class="nf">proximal_const_func</span><span class="p">(</span><span class="n">space</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the constant functional.</span>

<span class="sd">    Function to initialize the proximal operator of the constant functional</span>
<span class="sd">    defined on ``space``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of the functional G=constant</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The constant functional :math:`G` is defind as :math:`G(x) = constant`</span>
<span class="sd">    for all values of :math:`x`. The proximal operator of this functional is</span>
<span class="sd">    the identity operator</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma G}(x) = x</span>

<span class="sd">    Note that it is independent of :math:`\\sigma`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">identity_factory</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an instance of the proximal operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : positive float</span>
<span class="sd">            Unused step size parameter. Introduced to provide a unified</span>
<span class="sd">            interface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        id : `IdentityOperator`</span>
<span class="sd">            The proximal operator instance of G = 0 which is the</span>
<span class="sd">            identity operator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">identity_factory</span></div>


<div class="viewcode-block" id="proximal_box_constraint"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_box_constraint.html#odl.solvers.nonsmooth.proximal_operators.proximal_box_constraint">[docs]</a><span class="k">def</span> <span class="nf">proximal_box_constraint</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory for ``G(x) = ind(a &lt;= x &lt;= b)``.</span>

<span class="sd">    If P is the set of elements with a &lt;= x &lt;= b, the indicator function of</span>
<span class="sd">    which is defined as::</span>

<span class="sd">        ind(a &lt;= x &lt;= b) = {0 if x in P, infinity if x is not in P}</span>

<span class="sd">    with x being an element in ``space``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of the functional G(x)</span>
<span class="sd">    lower : ``space.field`` element or ``space`` `element-like`, optional</span>
<span class="sd">        The lower bound.</span>
<span class="sd">        Default: ``None``, interpreted as -infinity</span>
<span class="sd">    upper : ``space.field`` element or ``space`` `element-like`, optional</span>
<span class="sd">        The upper bound.</span>
<span class="sd">        Default: ``None``, interpreted as +infinity</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If :math:`P` is an interval :math:`[a,b]`, the indicator function is</span>
<span class="sd">    defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        I_{P}(x) = \\begin{cases}</span>
<span class="sd">        0 &amp; \\text{if } x \\in P, \\\\</span>
<span class="sd">        \\infty &amp; \\text{if } x \\not \\in P</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of</span>
<span class="sd">    :math:`\\sigma I_{P}` is given by the projection onto the interval</span>

<span class="sd">    .. math::</span>
<span class="sd">         \mathrm{prox}_{\\sigma I_{P}}(x) = \\begin{cases}</span>
<span class="sd">         a &amp; \\text{if } x &lt; a, \\\\</span>
<span class="sd">         x &amp; \\text{if } x \\in [a,b], \\\\</span>
<span class="sd">         b &amp; \\text{if } x &gt; b.</span>
<span class="sd">         \\end{cases}</span>

<span class="sd">    The proximal operator is independent of :math:`\\sigma` and invariant under</span>
<span class="sd">    a positive rescaling of :math:`I_{P}(x)`, since that leaves the indicator</span>
<span class="sd">    function unchanged.</span>

<span class="sd">    For spaces of the form :math:`R^n`, the definition extends naturally</span>
<span class="sd">    in each component.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_nonnegativity : Special case with ``lower=0, upper=infty``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert element-likes if needed, also does some space checking</span>
    <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lower</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span> <span class="ow">and</span> <span class="n">lower</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lower</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">field</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">in</span> <span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid values, `lower` (</span><span class="si">{}</span><span class="s1">) &gt; `upper` (</span><span class="si">{}</span><span class="s1">)&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProxOpBoxConstraint</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator for G(x) = ind(a &lt;= x &lt;= b).&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">                Step size parameter, not used.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProxOpBoxConstraint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and store the result in ``out``.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ProxOpBoxConstraint</span></div>


<div class="viewcode-block" id="proximal_nonnegativity"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_nonnegativity.html#odl.solvers.nonsmooth.proximal_operators.proximal_nonnegativity">[docs]</a><span class="k">def</span> <span class="nf">proximal_nonnegativity</span><span class="p">(</span><span class="n">space</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to create the proximal operator of ``G(x) = ind(x &gt;= 0)``.</span>

<span class="sd">    Function for the proximal operator of the functional ``G(x)=ind(x &gt;= 0)``</span>
<span class="sd">    to be initialized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of the functional G(x)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_box_constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">proximal_box_constraint</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="proximal_convex_conj_l2"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l2.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l2">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj_l2</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the convex conj of the l2-norm/distance.</span>

<span class="sd">    Function for the proximal operator of the convex conjugate of the</span>
<span class="sd">    functional F where F is the l2-norm (or distance to g, if given)::</span>

<span class="sd">        F(x) =  lam ||x - g||_2</span>

<span class="sd">    with x and g elements in ``space``, scaling factor lam, and given data g.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of F(x). Needs to be a Hilbert space.</span>
<span class="sd">        That is, have an inner product (`LinearSpace.inner`).</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Most problems are forumlated for the squared norm/distance, in that case</span>
<span class="sd">    use the `proximal_convex_conj_l2_squared` instead.</span>

<span class="sd">    The :math:`L_2`-norm/distance :math:`F` is given by is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \|x - g\|_2</span>

<span class="sd">    The convex conjugate :math:`F^*` of :math:`F` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(y) = \\begin{cases}</span>
<span class="sd">        0 &amp; \\text{if } \|y-g\|_2 \leq \\lambda, \\\\</span>
<span class="sd">        \\infty &amp; \\text{else.}</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of</span>
<span class="sd">    :math:`\\sigma F^*` is given by the projection onto the set of :math:`y`</span>
<span class="sd">    satisfying :math:`\|y-g\|_2 \leq \\lambda`, i.e., by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(y) = \\begin{cases}</span>
<span class="sd">        \\lambda \\frac{y - g}{\|y - g\|}</span>
<span class="sd">        &amp; \\text{if } \|y-g\|_2 &gt; \\lambda, \\\\</span>
<span class="sd">        y &amp; \\text{if } \|y-g\|_2 \leq \\lambda</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    Note that the expression is independent of :math:`\sigma`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_l2 : proximal without convex conjugate</span>
<span class="sd">    proximal_convex_conj_l2_squared : proximal for squared norm/distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prox_l2</span> <span class="o">=</span> <span class="n">proximal_l2</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="n">prox_l2</span><span class="p">)</span></div>


<div class="viewcode-block" id="proximal_l2"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_l2.html#odl.solvers.nonsmooth.proximal_operators.proximal_l2">[docs]</a><span class="k">def</span> <span class="nf">proximal_l2</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the l2-norm/distance.</span>

<span class="sd">    Function for the proximal operator of the functional ``F`` where ``F``</span>
<span class="sd">    is the l2-norm (or distance to g, if given)::</span>

<span class="sd">        ``F(x) =  lam ||x - g||_2``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of F(x). Needs to be a Hilbert space.</span>
<span class="sd">        That is, have an inner product (`LinearSpace.inner`).</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : callable</span>
<span class="sd">        Factory for the proximal operator to be initialized.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Most problems are forumlated for the squared norm/distance, in that case</span>
<span class="sd">    use `proximal_l2_squared` instead.</span>

<span class="sd">    The :math:`L_2`-norm/distance :math:`F` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \|x - g\|_2</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of :math:`\\sigma F`</span>
<span class="sd">    is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F}(y) = \\begin{cases}</span>
<span class="sd">        \\frac{1 - c}{\|y-g\|} \\cdot y  + c \cdot g</span>
<span class="sd">        &amp; \\text{if } c &lt; g, \\\\</span>
<span class="sd">        g &amp; \\text{else},</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    where :math:`c = \\sigma \\frac{\\lambda}{\|y - g\|_2}`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_l2_squared : proximal for squared norm/distance</span>
<span class="sd">    proximal_convex_conj_l2 : proximal for convex conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not an element of </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProximalL2</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator of the l2-norm/distance.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">                Step size parameter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProximalL2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and stores the result in ``out``.&quot;&quot;&quot;</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">10</span>

            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x_norm</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">/</span> <span class="n">x_norm</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span>

                <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">set_zero</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">/</span> <span class="n">x_norm</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span>

                <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ProximalL2</span></div>


<div class="viewcode-block" id="proximal_convex_conj_l2_squared"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l2_squared.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l2_squared">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj_l2_squared</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the convex conj of the squared l2-norm/dist</span>

<span class="sd">    Function for the proximal operator of the convex conjugate of the</span>
<span class="sd">    functional F where F is the l2-norm (or distance to g, if given)::</span>

<span class="sd">        F(x) =  lam ||x - g||_2^2</span>

<span class="sd">    with x and g elements in ``space``, scaling factor lam, and given data g.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of F(x). Needs to be a Hilbert space.</span>
<span class="sd">        That is, have an inner product (`LinearSpace.inner`).</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The squared :math:`L_2`-norm/distance :math:`F` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) =  \\lambda \|x - g\|_2^2.</span>

<span class="sd">    The convex conjugate :math:`F^*` of :math:`F` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(y) = \\frac{1}{4\\lambda} \left( \|</span>
<span class="sd">        y\|_2^2 + \langle y, g \\rangle \\right)</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of</span>
<span class="sd">    :math:`\\sigma F^*` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(y) = \\frac{y - \\sigma g}{1 +</span>
<span class="sd">        \\sigma/(2 \\lambda)}</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_convex_conj_l2 : proximal without square</span>
<span class="sd">    proximal_l2_squared : proximal without convex conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not an element of </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProximalConvexConjL2Squared</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator of the convex conj of the squared l2-norm/dist.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">                Step size parameter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProximalConvexConjL2Squared</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and stores the result in ``out``&quot;&quot;&quot;</span>

            <span class="c1"># (x - sig*g) / (1 + sig/(2 lam))</span>

            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sig</span> <span class="o">/</span> <span class="n">lam</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sig</span> <span class="o">/</span> <span class="n">lam</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span>
                            <span class="o">-</span><span class="n">sig</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sig</span> <span class="o">/</span> <span class="n">lam</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ProximalConvexConjL2Squared</span></div>


<div class="viewcode-block" id="proximal_l2_squared"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_l2_squared.html#odl.solvers.nonsmooth.proximal_operators.proximal_l2_squared">[docs]</a><span class="k">def</span> <span class="nf">proximal_l2_squared</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the squared l2-norm/distance.</span>

<span class="sd">    Function for the proximal operator of the convex conjugate of the</span>
<span class="sd">    functional F where F is the l2-norm (or distance to g, if given)::</span>

<span class="sd">        F(x) =  lam ||x - g||_2^2</span>

<span class="sd">    with x and g elements in ``space``, scaling factor lam, and given data g.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace`</span>
<span class="sd">        Domain of F(x). Needs to be a Hilbert space.</span>
<span class="sd">        That is, have an inner product (`LinearSpace.inner`).</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The squared :math:`L_2`-norm/distance :math:`F` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) =  \\lambda \|x - g\|_2^2.</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of :math:`\\sigma F`</span>
<span class="sd">    is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F}(x) = \\frac{x + 2 \\sigma \\lambda g}</span>
<span class="sd">        {1 + 2 \\sigma \\lambda}.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_l2 : proximal without square</span>
<span class="sd">    proximal_convex_conj_l2_squared : proximal for convex conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: optimize</span>
    <span class="n">prox_cc_l2_squared</span> <span class="o">=</span> <span class="n">proximal_convex_conj_l2_squared</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="n">prox_cc_l2_squared</span><span class="p">)</span></div>


<div class="viewcode-block" id="proximal_convex_conj_l1"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l1.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l1">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj_l1</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the convex conj of the l1-norm/distance.</span>

<span class="sd">    Function for the proximal operator of the convex conjugate of the</span>
<span class="sd">    functional ``F`` where ``F`` is an l1-norm (or distance to g, if given)::</span>

<span class="sd">        F(x) = lam ||x - g||_1</span>

<span class="sd">    with x and g elements in ``space`` and scaling factor lam.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace` or `ProductSpace` of `LinearSpace` spaces</span>
<span class="sd">        Domain of the functional F</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>
<span class="sd">    isotropic : bool, optional</span>
<span class="sd">        If ``True``, take the vectorial 2-norm point-wise. Otherwise,</span>
<span class="sd">        use the vectorial 1-norm. Only available if ``space`` is a</span>
<span class="sd">        `ProductSpace`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The :math:`L_1`-norm/distance :math:`F` is the functional</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \|x - g\|_1.</span>

<span class="sd">    The convex conjugate :math:`F^*` of :math:`F` is given by the indicator</span>
<span class="sd">    function of the set :math:`Q_\\lambda`</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(y) = I_{Q_\\lambda} \left(</span>
<span class="sd">        \left| \\frac{y}{\\lambda} \\right| +</span>
<span class="sd">        \left\\langle \\frac{y}{\\lambda}, g \\right\\rangle</span>
<span class="sd">        \\right)</span>

<span class="sd">    where :math:`Q_\\lambda` is a hypercube centered at the origin with</span>
<span class="sd">    width :math:`2 \\lambda`.</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of</span>
<span class="sd">    :math:`\\sigma F^*` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(y) = \\frac{\\lambda (y - \\sigma g)}{</span>
<span class="sd">        \\max(\\lambda, |y - \\sigma g|)}</span>

<span class="sd">    An alternative formulation is available for `ProductSpace`&#39;s, in which</span>
<span class="sd">    case the ``isotropic`` parameter can be used, giving</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \| \|x - g\|_2 \|_1</span>

<span class="sd">    In this case, the dual is</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(y) = \\lambda I_{Q_\\lambda} \left(</span>
<span class="sd">        \left|\left| \\frac{y}{\\lambda} \\right|\\right|_2 +</span>
<span class="sd">        \left\langle \\frac{y}{\\lambda}, g \\right\\rangle</span>
<span class="sd">        \\right)</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of</span>
<span class="sd">    :math:`\\sigma F^*` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F^*}(y) = \\frac{\\lambda (y - \\sigma g)}{</span>
<span class="sd">        \\max(\\lambda, \|y - \\sigma g\|_2)}</span>

<span class="sd">    where :math:`\\max( \cdot , \cdot)` thresholds the lower bound of</span>
<span class="sd">    :math:`\|y\|_2` point-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_l1 : proximal without convex conjugate conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Fix for rounding errors</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">10</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not an element of </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">isotropic</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">or</span>
                       <span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`isotropic` given with non-powerspace `space`(</span><span class="si">{}</span><span class="s1">)&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">space</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProximalConvexConjL1</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator of the convex conj of the l1-norm/distance.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">                Step size parameter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># sigma is not used</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProximalConvexConjL1</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and store the result in ``out``.&quot;&quot;&quot;</span>

            <span class="c1"># lam * (x - sigma * g) / max(lam, |x - sigma * g|)</span>

            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">g</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">x</span>

            <span class="k">if</span> <span class="n">isotropic</span><span class="p">:</span>
                <span class="c1"># Calculate |x| = pointwise 2-norm of x</span>

                <span class="n">tmp</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">sq_tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">x_i</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">x_i</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sq_tmp</span><span class="p">)</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="n">sq_tmp</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

                <span class="c1"># Pointwise maximum of |x| and lambda</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

                <span class="c1"># Global scaling</span>
                <span class="n">tmp</span> <span class="o">/=</span> <span class="n">lam</span>

                <span class="c1"># Pointwise division</span>
                <span class="k">for</span> <span class="n">out_i</span><span class="p">,</span> <span class="n">x_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">diff</span><span class="p">):</span>
                    <span class="n">x_i</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_i</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate |x| = pointwise 2-norm of x</span>
                <span class="n">diff</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

                <span class="c1"># Pointwise maximum of |x| and lambda</span>
                <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

                <span class="c1"># Global scaling</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="n">lam</span>

                <span class="c1"># Pointwise division</span>
                <span class="n">diff</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ProximalConvexConjL1</span></div>


<div class="viewcode-block" id="proximal_l1"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_l1.html#odl.solvers.nonsmooth.proximal_operators.proximal_l1">[docs]</a><span class="k">def</span> <span class="nf">proximal_l1</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the l1-norm/distance.</span>

<span class="sd">    Function for the proximal operator of the functional F where F is an</span>
<span class="sd">    l1-norm (or distance to g, if given)::</span>

<span class="sd">        F(x) = lam ||x - g||_1</span>

<span class="sd">    with x and g elements in ``space``, and scaling factor lam.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `LinearSpace` or `ProductSpace`</span>
<span class="sd">        Domain of the functional.</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor or regularization parameter.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        An element in ``space``. Default: ``space.zero``.</span>
<span class="sd">    isotropic : bool, optional</span>
<span class="sd">        If ``True``, take the vectorial 2-norm point-wise. Otherwise,</span>
<span class="sd">        use the vectorial 1-norm. Only available if ``space`` is a</span>
<span class="sd">        `ProductSpace`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The :math:`L_1`-norm/distance :math:`F` is the functional</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \|x - g\|_1.</span>

<span class="sd">    For a step size :math:`\\sigma`, the proximal operator of :math:`\\sigma F`</span>
<span class="sd">    is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma F}(y) = \\begin{cases}</span>
<span class="sd">        y - \\sigma \\lambda</span>
<span class="sd">        &amp; \\text{if } y &gt; g + \\sigma \\lambda, \\\\</span>
<span class="sd">        0</span>
<span class="sd">        &amp; \\text{if } g - \\sigma \\lambda \\leq y \\leq g +</span>
<span class="sd">        \\sigma \\lambda \\\\</span>
<span class="sd">        y + \\sigma \\lambda</span>
<span class="sd">        &amp; \\text{if } y &lt; g - \\sigma \\lambda,</span>
<span class="sd">        \\end{cases}</span>

<span class="sd">    An alternative formulation is available for `ProductSpace`&#39;s, where the</span>
<span class="sd">    the ``isotropic`` parameter can be used, giving</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\lambda \| \|x - g\|_2 \|_1</span>

<span class="sd">    The proximal can be calculated using the Moreau equality (also known as</span>
<span class="sd">    Moreau decomposition or Moreau identity). See for example [BC2011].</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_convex_conj_l1 : proximal for convex conjugate</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [BC2011] Bauschke, H H, and Combettes, P L. *Convex analysis and</span>
<span class="sd">    monotone operator theory in Hilbert spaces*. Springer, 2011.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: optimize</span>
    <span class="n">prox_cc_l1</span> <span class="o">=</span> <span class="n">proximal_convex_conj_l1</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
                                         <span class="n">isotropic</span><span class="o">=</span><span class="n">isotropic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="n">prox_cc_l1</span><span class="p">)</span></div>


<div class="viewcode-block" id="proximal_convex_conj_kl"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj_kl</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal operator factory of the convex conjugate of the KL divergence.</span>

<span class="sd">    Function returning the proximal operator of the convex conjugate of the</span>
<span class="sd">    functional F where F is the entropy-type Kullback-Leibler (KL) divergence::</span>

<span class="sd">        F(x) = sum_i (x_i - g_i + g_i ln(g_i) - g_i ln(pos(x_i))) + ind_P(x)</span>

<span class="sd">    with ``x`` and ``g`` elements in the linear space ``X``, and ``g``</span>
<span class="sd">    non-negative. Here, ``pos`` denotes the nonnegative part, and ``ind_P`` is</span>
<span class="sd">    the indicator function for nonnegativity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `FnBase`</span>
<span class="sd">        Space X which is the domain of the functional F</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        Data term, positive. If None it is take as the one-element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_convex_conj_kl_cross_entropy : proximal for releated functional</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional is given by the expression</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\sum_i (x_i - g_i + g_i \\ln(g_i) - g_i \\ln(pos(x_i))) +</span>
<span class="sd">        I_{x \\geq 0}(x)</span>

<span class="sd">    The indicator function :math:`I_{x \geq 0}(x)` is used to restrict the</span>
<span class="sd">    domain of :math:`F` such that :math:`F` is defined over whole space</span>
<span class="sd">    :math:`X`. The non-negativity thresholding :math:`pos` is used to define</span>
<span class="sd">    :math:`F` in the real numbers.</span>

<span class="sd">    Note that the functional is not well-defined without a prior g. Hence, if g</span>
<span class="sd">    is omitted this will be interpreted as if g is equal to the one-element.</span>

<span class="sd">    The convex conjugate :math:`F^*` of :math:`F` is</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(p) = \\sum_i (-g_i \\ln(pos({1_X}_i - p_i))) +</span>
<span class="sd">        I_{1_X - p \geq 0}(p)</span>

<span class="sd">    where :math:`p` is the variable dual to :math:`x`, and :math:`1_X` is an</span>
<span class="sd">    element of the space :math:`X` with all components set to 1.</span>

<span class="sd">    The proximal operator of the convex conjugate of F is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma (\\lambda F)^*}(x) =</span>
<span class="sd">        \\frac{\\lambda 1_X + x - \\sqrt{(x -  \\lambda 1_X)^2 +</span>
<span class="sd">        4 \\lambda \\sigma g}}{2}</span>

<span class="sd">    where :math:`\\sigma` is the step size-like parameter, and :math:`\\lambda`</span>
<span class="sd">    is the weighting in front of the function :math:`F`.</span>

<span class="sd">    KL based objectives are common in MLEM optimization problems and are often</span>
<span class="sd">    used when data noise governed by a multivariate Poisson probability</span>
<span class="sd">    distribution is significant.</span>

<span class="sd">    The intermediate image estimates can have negative values even though</span>
<span class="sd">    the converged solution will be non-negative. Non-negative intermediate</span>
<span class="sd">    image estimates can be enforced by adding an indicator function ind_P</span>
<span class="sd">    the primal objective.</span>

<span class="sd">    This functional :math:`F`, described above, is related to the</span>
<span class="sd">    Kullback-Leibler cross entropy functional. The KL cross entropy is the one</span>
<span class="sd">    diescribed in `this Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&gt;`_, and</span>
<span class="sd">    the functional :math:`F` is obtained by switching place of the prior and</span>
<span class="sd">    the varialbe in the KL cross entropy functional. See the See Also section.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not an element of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProximalConvexConjKL</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator of the convex conjugate of the KL divergence.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProximalConvexConjKL</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and stores the result in ``out``.&quot;&quot;&quot;</span>

            <span class="c1"># 1 / 2 (lam_X + x - sqrt((x - lam_X) ^ 2 + 4; lam sigma g)</span>

            <span class="c1"># out = x - lam_X</span>
            <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">-=</span> <span class="n">lam</span>

            <span class="c1"># (out)^2</span>
            <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

            <span class="c1"># out = out + 4 lam sigma g</span>
            <span class="c1"># If g is None, it is taken as the one element</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

            <span class="c1"># out = sqrt(out)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

            <span class="c1"># out = x - out</span>
            <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

            <span class="c1"># out = lam_X + out</span>
            <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">one</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

            <span class="c1"># out = 1/2 * out</span>
            <span class="n">out</span> <span class="o">/=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">ProximalConvexConjKL</span></div>


<div class="viewcode-block" id="proximal_convex_conj_kl_cross_entropy"><a class="viewcode-back" href="../../../../generated/odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl_cross_entropy.html#odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">proximal_convex_conj_kl_cross_entropy</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximal factory of the convex conjugate of cross entropy KL divergence.</span>

<span class="sd">    Function returning the proximal factory of the convex conjugate of the</span>
<span class="sd">    functional F, where F is the cross entropy Kullback-Leibler (KL)</span>
<span class="sd">    divergence given by::</span>

<span class="sd">        F(x) = sum_i (x_i ln(pos(x_i)) - x_i ln(g_i) + g_i - x_i) + ind_P(x)</span>

<span class="sd">    with ``x`` and ``g`` in the linear space ``X``, and ``g`` non-negative.</span>
<span class="sd">    Here, ``pos`` denotes the nonnegative part, and ``ind_P`` is the indicator</span>
<span class="sd">    function for nonnegativity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `FnBase`</span>
<span class="sd">        Space X which is the domain of the functional F</span>
<span class="sd">    lam : positive float, optional</span>
<span class="sd">        Scaling factor.</span>
<span class="sd">    g : ``space`` element, optional</span>
<span class="sd">        Data term, positive. If None it is take as the one-element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prox_factory : function</span>
<span class="sd">        Factory for the proximal operator to be initialized.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    proximal_convex_conj_kl : proximal for related functional</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional is given by the expression</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \\sum_i (x_i \\ln(pos(x_i)) - x_i \\ln(g_i) + g_i - x_i) +</span>
<span class="sd">        I_{x \\geq 0}(x)</span>

<span class="sd">    The indicator function :math:`I_{x \geq 0}(x)` is used to restrict the</span>
<span class="sd">    domain of :math:`F` such that :math:`F` is defined over whole space</span>
<span class="sd">    :math:`X`. The non-negativity thresholding :math:`pos` is used to define</span>
<span class="sd">    :math:`F` in the real numbers.</span>

<span class="sd">    Note that the functional is not well-defined without a prior g. Hence, if g</span>
<span class="sd">    is omitted this will be interpreted as if g is equal to the one-element.</span>

<span class="sd">    The convex conjugate :math:`F^*` of :math:`F` is</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(p) = \\sum_i g_i (exp(p_i) - 1)</span>

<span class="sd">    where :math:`p` is the variable dual to :math:`x`.</span>

<span class="sd">    The proximal operator of the convex conjugate of :math:`F` is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\\sigma (\\lambda F)^*}(x) = x - \\lambda</span>
<span class="sd">        W(\\frac{\\sigma}{\\lambda} g e^{x/\\lambda})</span>

<span class="sd">    where :math:`\\sigma` is the step size-like parameter, :math:`\\lambda` is</span>
<span class="sd">    the weighting in front of the function :math:`F`, and :math:`W` is the</span>
<span class="sd">    Lambert W function (see, for example, the</span>
<span class="sd">    `Wikipedia article &lt;https://en.wikipedia.org/wiki/Lambert_W_function&gt;`_).</span>

<span class="sd">    For real-valued input x, the Lambert :math:`W` function is defined only for</span>
<span class="sd">    :math:`x \\geq -1/e`, and it has two branches for values</span>
<span class="sd">    :math:`-1/e \\leq x &lt; 0`. However, for inteneded use-cases, where</span>
<span class="sd">    :math:`\\lambda` and :math:`g` are positive, the argument of :math:`W`</span>
<span class="sd">    will always be positive.</span>

<span class="sd">    `Wikipedia article on Kullback Leibler divergence</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&gt;`_.</span>
<span class="sd">    For further information about the functional, see for example `this article</span>
<span class="sd">    &lt;http://ieeexplore.ieee.org/document/1056144/?arnumber=1056144&gt;`_.</span>

<span class="sd">    The KL cross entropy functional :math:`F`, described above, is related to</span>
<span class="sd">    another functional functional also know as KL divergence. This functional</span>
<span class="sd">    is often used as data discrepancy term in inverse problems, when data is</span>
<span class="sd">    corrupted with Poisson noise. This functional is obtained by changing place</span>
<span class="sd">    of the prior and the variable. See the See Also section.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">space</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not an element of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">space</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">ProximalConvexConjKLCrossEntropy</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Proximal operator of conjugate of cross entropy KL divergence.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ProximalConvexConjKLCrossEntropy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Apply the operator to ``x`` and stores the result in ``out``.&quot;&quot;&quot;</span>
            <span class="c1"># Lazy import to improve `import odl` time</span>
            <span class="kn">import</span> <span class="nn">scipy.special</span>

            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If g is None, it is taken as the one element</span>
                <span class="c1"># Different branches of lambertw is not an issue, see Notes</span>
                <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">lam</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">lambertw</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lam</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Different branches of lambertw is not an issue, see Notes</span>
                <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                            <span class="o">-</span><span class="n">lam</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">lambertw</span><span class="p">(</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">lam</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">ProximalConvexConjKLCrossEntropy</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># pylint: disable=wrong-import-position</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="k">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, ODL development group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.6.1.dev0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>